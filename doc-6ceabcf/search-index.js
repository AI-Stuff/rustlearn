var searchIndex = {};
searchIndex['rustlearn'] = {"items":[[0,"","rustlearn","A machine learning crate for Rust.",null,null],[0,"array","","Basic matrix-like datastructures.",null,null],[0,"dense","rustlearn::array","Basic two-dimensional dense matrix type.",null,null],[3,"Array","rustlearn::array::dense","Basic two-dimensional dense matrix type.",null,null],[3,"ArrayView","","A view into a row or column of an existing dense matrix.",null,null],[3,"ArrayIterator","","Iterator over row or column views of a dense matrix.",null,null],[3,"ArrayViewIterator","","Iterator over entries of a dense matrix view.",null,null],[3,"ArrayViewNonzeroIterator","","Iterator over nonzero entries of a dense matrix view.",null,null],[5,"allclose","","Determines whether two arrays are sufficiently close to each other.",null,{"inputs":[{"name":"array"},{"name":"array"}],"output":{"name":"bool"}}],[5,"close","","Determines whether two floats are sufficiently close to each other.",null,{"inputs":[{"name":"f32"},{"name":"f32"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"array"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"array"}],"output":{"name":"array"}}],[11,"fmt","","",1,{"inputs":[{"name":"arrayview"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"arrayview"}],"output":{"name":"arrayview"}}],[11,"next","","",2,{"inputs":[{"name":"arrayiterator"}],"output":{"name":"option"}}],[11,"next","","",3,{"inputs":[{"name":"arrayviewiterator"}],"output":{"name":"option"}}],[11,"next","","",4,{"inputs":[{"name":"arrayviewnonzeroiterator"}],"output":{"name":"option"}}],[11,"iter","","Iterate over elements of the `ArrayView`.",1,{"inputs":[{"name":"arrayview"}],"output":{"name":"arrayviewiterator"}}],[11,"iter_nonzero","","",1,{"inputs":[{"name":"arrayview"}],"output":{"name":"arrayviewnonzeroiterator"}}],[11,"rows","","",0,{"inputs":[{"name":"array"}],"output":{"name":"usize"}}],[11,"cols","","",0,{"inputs":[{"name":"array"}],"output":{"name":"usize"}}],[11,"get_unchecked","","",0,{"inputs":[{"name":"array"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"get_unchecked_mut","","",0,{"inputs":[{"name":"array"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"zeros","","Create a `rows` by `cols` array of zeros.",0,{"inputs":[{"name":"array"},{"name":"usize"},{"name":"usize"}],"output":{"name":"array"}}],[11,"ones","","Create a `rows` by `cols` array of ones.",0,{"inputs":[{"name":"array"},{"name":"usize"},{"name":"usize"}],"output":{"name":"array"}}],[11,"reshape","","Change the shape of the array to `rows` by `cols`.",0,{"inputs":[{"name":"array"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"order","","Return the order (row-major or column-major)\nof the array.",0,{"inputs":[{"name":"array"}],"output":{"name":"matrixorder"}}],[11,"data","","Return an immutable reference to the underlying\ndata buffer of the array.",0,{"inputs":[{"name":"array"}],"output":{"name":"vec"}}],[11,"as_slice","","Return an immutable reference to the underlying\ndata buffer of the array.",0,null],[11,"as_mut_slice","","Return an mutable reference to the underlying\ndata buffer of the array.",0,null],[11,"T","","Transpose the matrix.",0,{"inputs":[{"name":"array"}],"output":{"name":"array"}}],[11,"sum","","Compute the sum of the entries of the array.",0,{"inputs":[{"name":"array"}],"output":{"name":"f32"}}],[11,"mean","","Compute the mean of the array.",0,{"inputs":[{"name":"array"}],"output":{"name":"f32"}}],[11,"from","","Construct an array from a vector.",0,{"inputs":[{"name":"array"},{"name":"vec"}],"output":{"name":"array"}}],[11,"from","","Construct an array from a vector of vectors.",0,{"inputs":[{"name":"array"},{"name":"vec"}],"output":{"name":"array"}}],[11,"add","","",0,{"inputs":[{"name":"array"},{"name":"f32"}],"output":{"name":"array"}}],[11,"add_inplace","","",0,{"inputs":[{"name":"array"},{"name":"f32"}],"output":null}],[11,"sub","","",0,{"inputs":[{"name":"array"},{"name":"f32"}],"output":{"name":"array"}}],[11,"sub_inplace","","",0,{"inputs":[{"name":"array"},{"name":"f32"}],"output":null}],[11,"times","","",0,{"inputs":[{"name":"array"},{"name":"f32"}],"output":{"name":"array"}}],[11,"times_inplace","","",0,{"inputs":[{"name":"array"},{"name":"f32"}],"output":null}],[11,"div","","",0,{"inputs":[{"name":"array"},{"name":"f32"}],"output":{"name":"array"}}],[11,"div_inplace","","",0,{"inputs":[{"name":"array"},{"name":"f32"}],"output":null}],[11,"add","","",0,{"inputs":[{"name":"array"},{"name":"array"}],"output":{"name":"array"}}],[11,"add_inplace","","",0,{"inputs":[{"name":"array"},{"name":"array"}],"output":null}],[11,"sub","","",0,{"inputs":[{"name":"array"},{"name":"array"}],"output":{"name":"array"}}],[11,"sub_inplace","","",0,{"inputs":[{"name":"array"},{"name":"array"}],"output":null}],[11,"times","","",0,{"inputs":[{"name":"array"},{"name":"array"}],"output":{"name":"array"}}],[11,"times_inplace","","",0,{"inputs":[{"name":"array"},{"name":"array"}],"output":null}],[11,"div","","",0,{"inputs":[{"name":"array"},{"name":"array"}],"output":{"name":"array"}}],[11,"div_inplace","","",0,{"inputs":[{"name":"array"},{"name":"array"}],"output":null}],[11,"dot","","",0,{"inputs":[{"name":"array"},{"name":"array"}],"output":{"name":"array"}}],[11,"get_rows","","",0,{"inputs":[{"name":"array"},{"name":"vec"}],"output":{"name":"array"}}],[0,"sparse","rustlearn::array","Sparse matrices.",null,null],[3,"SparseRowArray","rustlearn::array::sparse","A sparse matrix with entries arranged row-wise.",null,null],[3,"SparseColumnArray","","A sparse matrix with entries arranged column-wise.",null,null],[3,"SparseArrayView","","A view into a row or a column of an existing sparse matrix.",null,null],[3,"SparseArrayViewIterator","","Iterator over nonzero entries of a SparseArrayView.",null,null],[3,"SparseArrayIterator","","Iterator over row or column views of a sparse matrix.",null,null],[11,"fmt","","",5,{"inputs":[{"name":"sparsearrayview"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"sparsearrayview"}],"output":{"name":"sparsearrayview"}}],[11,"rows","","",6,{"inputs":[{"name":"sparserowarray"}],"output":{"name":"usize"}}],[11,"cols","","",6,{"inputs":[{"name":"sparserowarray"}],"output":{"name":"usize"}}],[11,"get_unchecked","","",6,{"inputs":[{"name":"sparserowarray"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"get_unchecked_mut","","",6,{"inputs":[{"name":"sparserowarray"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"set_unchecked","","",6,{"inputs":[{"name":"sparserowarray"},{"name":"usize"},{"name":"usize"},{"name":"f32"}],"output":null}],[11,"rows","","",7,{"inputs":[{"name":"sparsecolumnarray"}],"output":{"name":"usize"}}],[11,"cols","","",7,{"inputs":[{"name":"sparsecolumnarray"}],"output":{"name":"usize"}}],[11,"get_unchecked","","",7,{"inputs":[{"name":"sparsecolumnarray"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"get_unchecked_mut","","",7,{"inputs":[{"name":"sparsecolumnarray"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"set_unchecked","","",7,{"inputs":[{"name":"sparsecolumnarray"},{"name":"usize"},{"name":"usize"},{"name":"f32"}],"output":null}],[11,"zeros","","Initialise an empty (`rows` by `cols`) matrix.",6,{"inputs":[{"name":"sparserowarray"},{"name":"usize"},{"name":"usize"}],"output":{"name":"sparserowarray"}}],[11,"nnz","","Return the number of nonzero entries.",6,{"inputs":[{"name":"sparserowarray"}],"output":{"name":"usize"}}],[11,"todense","","",6,{"inputs":[{"name":"sparserowarray"}],"output":{"name":"array"}}],[11,"from","","",6,{"inputs":[{"name":"sparserowarray"},{"name":"array"}],"output":{"name":"sparserowarray"}}],[11,"from","","",6,{"inputs":[{"name":"sparserowarray"},{"name":"sparsecolumnarray"}],"output":{"name":"sparserowarray"}}],[11,"zeros","","Initialise an empty (`rows` by `cols`) matrix.",7,{"inputs":[{"name":"sparsecolumnarray"},{"name":"usize"},{"name":"usize"}],"output":{"name":"sparsecolumnarray"}}],[11,"nnz","","Return the number of nonzero entries.",7,{"inputs":[{"name":"sparsecolumnarray"}],"output":{"name":"usize"}}],[11,"todense","","",7,{"inputs":[{"name":"sparsecolumnarray"}],"output":{"name":"array"}}],[11,"from","","",7,{"inputs":[{"name":"sparsecolumnarray"},{"name":"array"}],"output":{"name":"sparsecolumnarray"}}],[11,"from","","",7,{"inputs":[{"name":"sparsecolumnarray"},{"name":"sparserowarray"}],"output":{"name":"sparsecolumnarray"}}],[11,"iter_nonzero","","",5,{"inputs":[{"name":"sparsearrayview"}],"output":{"name":"sparsearrayviewiterator"}}],[11,"indices","","Returns a reference to indices of nonzero entries of the view.",5,null],[11,"data","","Returns a reference to values of nonzero entries of the view.",5,null],[11,"nnz","","Returns the count of  nonzero entries of the view.",5,{"inputs":[{"name":"sparsearrayview"}],"output":{"name":"usize"}}],[11,"next","","",8,{"inputs":[{"name":"sparsearrayviewiterator"}],"output":{"name":"option"}}],[11,"next","","",9,{"inputs":[{"name":"sparsearrayiterator"}],"output":{"name":"option"}}],[11,"get_rows","","",6,{"inputs":[{"name":"sparserowarray"},{"name":"vec"}],"output":{"name":"sparserowarray"}}],[0,"traits","rustlearn::array","Basic traits applying to all types of matrices.",null,null],[4,"MatrixOrder","rustlearn::array::traits","",null,null],[13,"RowMajor","","",10,null],[13,"ColumnMajor","","",10,null],[8,"IndexableMatrix","","Trait representing a shaped matrix whose entries can be accessed\nat will using their row and column position.",null,null],[10,"rows","","Return the number of rows of the matrix.",11,{"inputs":[{"name":"indexablematrix"}],"output":{"name":"usize"}}],[10,"cols","","Return the number of columns of the matrix.",11,{"inputs":[{"name":"indexablematrix"}],"output":{"name":"usize"}}],[10,"get_unchecked","","Get the value of the entry at (`row`, `column`) without bounds checking.",11,{"inputs":[{"name":"indexablematrix"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f32"}}],[10,"get_unchecked_mut","","Get a mutable reference to the value of the entry at (`row`, `column`) without bounds checking.",11,{"inputs":[{"name":"indexablematrix"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"get","","Get the value of the entry at (`row`, `column`).",11,{"inputs":[{"name":"indexablematrix"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"get_mut","","Get a mutable reference to value of the entry at (`row`, `column`).",11,{"inputs":[{"name":"indexablematrix"},{"name":"usize"},{"name":"usize"}],"output":{"name":"f32"}}],[11,"set","","Set the value of the entry at (`row`, `column`) to `value`.",11,{"inputs":[{"name":"indexablematrix"},{"name":"usize"},{"name":"usize"},{"name":"f32"}],"output":null}],[11,"set_unchecked","","Set the value of the entry at (`row`, `column`) to `value` without bounds checking.",11,{"inputs":[{"name":"indexablematrix"},{"name":"usize"},{"name":"usize"},{"name":"f32"}],"output":null}],[8,"RowIterable","","Trait representing a matrix that can be iterated over in\na row-wise fashion.",null,null],[16,"Output","","",12,null],[10,"iter_rows","","Iterate over rows of the matrix.",12,{"inputs":[{"name":"rowiterable"}],"output":{"name":"output"}}],[10,"view_row","","View a row of the matrix.",12,{"inputs":[{"name":"rowiterable"},{"name":"usize"}],"output":{"name":"t"}}],[8,"ColumnIterable","","Trait representing a matrix that can be iterated over in\na column-wise fashion.",null,null],[16,"Output","","",13,null],[10,"iter_columns","","Iterate over columns of a the matrix.",13,{"inputs":[{"name":"columniterable"}],"output":{"name":"output"}}],[10,"view_column","","View a column of the matrix.",13,{"inputs":[{"name":"columniterable"},{"name":"usize"}],"output":{"name":"t"}}],[8,"NonzeroIterable","","Trait representing an object whose non-zero\nentries can be iterated over.",null,null],[16,"Output","","",14,null],[10,"iter_nonzero","","",14,{"inputs":[{"name":"nonzeroiterable"}],"output":{"name":"output"}}],[8,"RowIndex","","Trait representing a matrix whose rows can be selected\nto create a new matrix containing those rows.",null,null],[16,"Output","","",15,null],[10,"get_rows","","",15,{"inputs":[{"name":"rowindex"},{"name":"rhs"}],"output":{"name":"output"}}],[8,"ElementwiseArrayOps","","Elementwise array operations trait.",null,null],[16,"Output","","",16,null],[10,"add","","",16,{"inputs":[{"name":"elementwisearrayops"},{"name":"rhs"}],"output":{"name":"output"}}],[10,"add_inplace","","",16,{"inputs":[{"name":"elementwisearrayops"},{"name":"rhs"}],"output":null}],[10,"sub","","",16,{"inputs":[{"name":"elementwisearrayops"},{"name":"rhs"}],"output":{"name":"output"}}],[10,"sub_inplace","","",16,{"inputs":[{"name":"elementwisearrayops"},{"name":"rhs"}],"output":null}],[10,"times","","",16,{"inputs":[{"name":"elementwisearrayops"},{"name":"rhs"}],"output":{"name":"output"}}],[10,"times_inplace","","",16,{"inputs":[{"name":"elementwisearrayops"},{"name":"rhs"}],"output":null}],[10,"div","","",16,{"inputs":[{"name":"elementwisearrayops"},{"name":"rhs"}],"output":{"name":"output"}}],[10,"div_inplace","","",16,{"inputs":[{"name":"elementwisearrayops"},{"name":"rhs"}],"output":null}],[8,"Dot","","A matrix multiplication trait.",null,null],[16,"Output","","",17,null],[10,"dot","","",17,{"inputs":[{"name":"dot"},{"name":"rhs"}],"output":{"name":"output"}}],[11,"fmt","","",10,{"inputs":[{"name":"matrixorder"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"matrixorder"}],"output":{"name":"matrixorder"}}],[0,"prelude","rustlearn::array","Prelude containing basic matrix-like structures and traits.",null,null],[0,"cross_validation","rustlearn","Cross validation utilities.",null,null],[0,"cross_validation","rustlearn::cross_validation","K-fold cross validation.",null,null],[3,"CrossValidation","rustlearn::cross_validation::cross_validation","",null,null],[11,"new","","Create a new instance of the cross validation utility.",18,{"inputs":[{"name":"crossvalidation"},{"name":"usize"},{"name":"usize"}],"output":{"name":"crossvalidation"}}],[11,"set_rng","","Fix the random number generator.",18,{"inputs":[{"name":"crossvalidation"},{"name":"stdrng"}],"output":null}],[11,"next","","",18,{"inputs":[{"name":"crossvalidation"}],"output":{"name":"option"}}],[0,"shuffle_split","rustlearn::cross_validation","Validation via repeated random shuffling\nof the data and splitting into a training and test set.",null,null],[3,"ShuffleSplit","rustlearn::cross_validation::shuffle_split","",null,null],[11,"new","","Create a new instance of the shuffle split utility.",19,{"inputs":[{"name":"shufflesplit"},{"name":"usize"},{"name":"usize"},{"name":"f32"}],"output":{"name":"shufflesplit"}}],[11,"set_rng","","Set the random number generator.",19,{"inputs":[{"name":"shufflesplit"},{"name":"stdrng"}],"output":null}],[11,"next","","",19,{"inputs":[{"name":"shufflesplit"}],"output":{"name":"option"}}],[0,"datasets","rustlearn","Datasets and dataset loading utilities.",null,null],[0,"iris","rustlearn::datasets","The iris dataset.",null,null],[5,"load_data","rustlearn::datasets::iris","Load the iris dataset, returning a tuple of (features, class labels).",null,null],[0,"ensemble","rustlearn","Ensemble models.",null,null],[0,"random_forest","rustlearn::ensemble","Random forests.",null,null],[3,"Hyperparameters","rustlearn::ensemble::random_forest","",null,null],[3,"RandomForest","","",null,null],[11,"new","","Create a new instance of Hyperparameters, using the Hyperparameters\nfor a `DecisionTree` and the number of trees to build.",20,{"inputs":[{"name":"hyperparameters"},{"name":"hyperparameters"},{"name":"usize"}],"output":{"name":"hyperparameters"}}],[11,"rng","","Set the random number generator.",20,{"inputs":[{"name":"hyperparameters"},{"name":"stdrng"}],"output":{"name":"hyperparameters"}}],[11,"build","","Build the random forest model.",20,{"inputs":[{"name":"hyperparameters"}],"output":{"name":"randomforest"}}],[11,"one_vs_rest","","Build a one-vs-rest multiclass random forest.",20,{"inputs":[{"name":"hyperparameters"}],"output":{"name":"onevsrestwrapper"}}],[11,"clone","","",21,{"inputs":[{"name":"randomforest"}],"output":{"name":"randomforest"}}],[11,"fit","","",21,{"inputs":[{"name":"randomforest"},{"name":"array"},{"name":"array"}],"output":{"name":"result"}}],[11,"decision_function","","",21,{"inputs":[{"name":"randomforest"},{"name":"array"}],"output":{"name":"result"}}],[11,"fit","","",21,{"inputs":[{"name":"randomforest"},{"name":"sparserowarray"},{"name":"array"}],"output":{"name":"result"}}],[11,"decision_function","","",21,{"inputs":[{"name":"randomforest"},{"name":"sparserowarray"}],"output":{"name":"result"}}],[11,"trees","","Return a reference to the consituent trees vector.",21,{"inputs":[{"name":"randomforest"}],"output":{"name":"vec"}}],[0,"linear_models","rustlearn","Linear models.",null,null],[0,"sgdclassifier","rustlearn::linear_models","A two-class logistic regression classifier implemented using stochastic gradient descent.",null,null],[3,"Hyperparameters","rustlearn::linear_models::sgdclassifier","Hyperparameters for a SGDClassifier model.",null,null],[3,"SGDClassifier","","A two-class linear regression classifier implemented using stochastic gradient descent.",null,null],[11,"new","","Creates new Hyperparameters.",22,{"inputs":[{"name":"hyperparameters"},{"name":"usize"}],"output":{"name":"hyperparameters"}}],[11,"learning_rate","","Set the initial learning rate.",22,{"inputs":[{"name":"hyperparameters"},{"name":"f32"}],"output":{"name":"hyperparameters"}}],[11,"l2_penalty","","Set the L2 penalty.",22,{"inputs":[{"name":"hyperparameters"},{"name":"f32"}],"output":{"name":"hyperparameters"}}],[11,"l1_penalty","","Set the L1 penalty.",22,{"inputs":[{"name":"hyperparameters"},{"name":"f32"}],"output":{"name":"hyperparameters"}}],[11,"build","","Build a two-class model.",22,{"inputs":[{"name":"hyperparameters"}],"output":{"name":"sgdclassifier"}}],[11,"one_vs_rest","","Build a one-vs-rest multiclass model.",22,{"inputs":[{"name":"hyperparameters"}],"output":{"name":"onevsrestwrapper"}}],[11,"clone","","",23,{"inputs":[{"name":"sgdclassifier"}],"output":{"name":"sgdclassifier"}}],[11,"fit","","",23,{"inputs":[{"name":"sgdclassifier"},{"name":"array"},{"name":"array"}],"output":{"name":"result"}}],[11,"decision_function","","",23,{"inputs":[{"name":"sgdclassifier"},{"name":"array"}],"output":{"name":"result"}}],[11,"fit","","",23,{"inputs":[{"name":"sgdclassifier"},{"name":"sparserowarray"},{"name":"array"}],"output":{"name":"result"}}],[11,"decision_function","","",23,{"inputs":[{"name":"sgdclassifier"},{"name":"sparserowarray"}],"output":{"name":"result"}}],[11,"get_coefficients","","Returns a reference to the estimated coefficients vector.",23,{"inputs":[{"name":"sgdclassifier"}],"output":{"name":"array"}}],[0,"metrics","rustlearn","Accuracy metrics.",null,null],[5,"accuracy_score","rustlearn::metrics","Measure classifier accuracy",null,{"inputs":[{"name":"array"},{"name":"array"}],"output":{"name":"f32"}}],[0,"multiclass","rustlearn","Utilities for mutliclass classifiers.",null,null],[3,"OneVsRest","rustlearn::multiclass","",null,null],[3,"OneVsRestWrapper","","Wraps simple two-class classifiers to implement one-vs-rest strategies.",null,null],[11,"split","","",24,{"inputs":[{"name":"onevsrest"},{"name":"array"}],"output":{"name":"onevsrest"}}],[11,"merge","","",24,{"inputs":[{"name":"onevsrest"},{"name":"vec"},{"name":"vec"}],"output":{"name":"array"}}],[11,"next","","",24,{"inputs":[{"name":"onevsrest"}],"output":{"name":"option"}}],[11,"new","","",25,{"inputs":[{"name":"onevsrestwrapper"},{"name":"t"}],"output":{"name":"onevsrestwrapper"}}],[11,"models","","",25,{"inputs":[{"name":"onevsrestwrapper"}],"output":{"name":"vec"}}],[11,"class_labels","","",25,{"inputs":[{"name":"onevsrestwrapper"}],"output":{"name":"vec"}}],[11,"fit","","",25,{"inputs":[{"name":"onevsrestwrapper"},{"name":"array"},{"name":"array"}],"output":{"name":"result"}}],[11,"decision_function","","",25,{"inputs":[{"name":"onevsrestwrapper"},{"name":"array"}],"output":{"name":"result"}}],[11,"predict","","",25,{"inputs":[{"name":"onevsrestwrapper"},{"name":"array"}],"output":{"name":"result"}}],[11,"fit","","",25,{"inputs":[{"name":"onevsrestwrapper"},{"name":"sparserowarray"},{"name":"array"}],"output":{"name":"result"}}],[11,"decision_function","","",25,{"inputs":[{"name":"onevsrestwrapper"},{"name":"sparserowarray"}],"output":{"name":"result"}}],[11,"predict","","",25,{"inputs":[{"name":"onevsrestwrapper"},{"name":"sparserowarray"}],"output":{"name":"result"}}],[11,"fit","","",25,{"inputs":[{"name":"onevsrestwrapper"},{"name":"sparsecolumnarray"},{"name":"array"}],"output":{"name":"result"}}],[11,"decision_function","","",25,{"inputs":[{"name":"onevsrestwrapper"},{"name":"sparsecolumnarray"}],"output":{"name":"result"}}],[11,"predict","","",25,{"inputs":[{"name":"onevsrestwrapper"},{"name":"sparsecolumnarray"}],"output":{"name":"result"}}],[0,"feature_extraction","rustlearn","Feature extraction utilities.",null,null],[0,"dict_vectorizer","rustlearn::feature_extraction","`DictVectorizer` vectorizers a set of named features into a sparse array\nvia one-hot encoding.",null,null],[3,"DictVectorizer","rustlearn::feature_extraction::dict_vectorizer","",null,null],[11,"new","","Create a new `DictVectorizer`.",26,{"inputs":[{"name":"dictvectorizer"}],"output":{"name":"dictvectorizer"}}],[11,"partial_fit","","Set the feature value of a named feature in a given row.",26,{"inputs":[{"name":"dictvectorizer"},{"name":"usize"},{"name":"str"},{"name":"f32"}],"output":null}],[11,"transform","","Transform the accumulated data into a sparse array.",26,{"inputs":[{"name":"dictvectorizer"}],"output":{"name":"sparserowarray"}}],[11,"dictionary","","Return a reference to the feature dictionary, mapping\nfeature names to their (column index, occurrence count).",26,{"inputs":[{"name":"dictvectorizer"}],"output":{"name":"hashmap"}}],[0,"trees","rustlearn","Decision trees.",null,null],[0,"decision_tree","rustlearn::trees","A two-class decision tree classifer.",null,null],[3,"Hyperparameters","rustlearn::trees::decision_tree","Hyperparameters for a DecisionTree model.",null,null],[3,"DecisionTree","","A two-class decision tree.",null,null],[11,"clone","","",27,{"inputs":[{"name":"hyperparameters"}],"output":{"name":"hyperparameters"}}],[11,"new","","Creates new Hyperparameters",27,{"inputs":[{"name":"hyperparameters"},{"name":"usize"}],"output":{"name":"hyperparameters"}}],[11,"max_features","","Set the maximum number of features to be considered when\nfinding the best split for the decision tree.",27,{"inputs":[{"name":"hyperparameters"},{"name":"usize"}],"output":{"name":"hyperparameters"}}],[11,"min_samples_split","","Set the minimum number of samples that must be present\nin order for further splitting to take place.",27,{"inputs":[{"name":"hyperparameters"},{"name":"usize"}],"output":{"name":"hyperparameters"}}],[11,"max_depth","","Set the maximum depth of the tree.",27,{"inputs":[{"name":"hyperparameters"},{"name":"usize"}],"output":{"name":"hyperparameters"}}],[11,"rng","","Set the random number generator used for sampling features\nto consider at each split.",27,{"inputs":[{"name":"hyperparameters"},{"name":"stdrng"}],"output":{"name":"hyperparameters"}}],[11,"build","","Build a binary decision tree model.",27,{"inputs":[{"name":"hyperparameters"}],"output":{"name":"decisiontree"}}],[11,"one_vs_rest","","Build a one-vs-rest multi-class decision tree model.",27,{"inputs":[{"name":"hyperparameters"}],"output":{"name":"onevsrestwrapper"}}],[11,"clone","","",28,{"inputs":[{"name":"decisiontree"}],"output":{"name":"decisiontree"}}],[11,"fit","","",28,{"inputs":[{"name":"decisiontree"},{"name":"array"},{"name":"array"}],"output":{"name":"result"}}],[11,"decision_function","","",28,{"inputs":[{"name":"decisiontree"},{"name":"array"}],"output":{"name":"result"}}],[11,"fit","","",28,{"inputs":[{"name":"decisiontree"},{"name":"sparsecolumnarray"},{"name":"array"}],"output":{"name":"result"}}],[11,"decision_function","","",28,{"inputs":[{"name":"decisiontree"},{"name":"sparsecolumnarray"}],"output":{"name":"result"}}],[0,"traits","rustlearn","Common rustlearn traits.",null,null],[8,"SupervisedModel","rustlearn::traits","",null,null],[10,"fit","","",29,{"inputs":[{"name":"supervisedmodel"},{"name":"t"},{"name":"array"}],"output":{"name":"result"}}],[10,"decision_function","","",29,{"inputs":[{"name":"supervisedmodel"},{"name":"t"}],"output":{"name":"result"}}],[11,"predict","","",29,{"inputs":[{"name":"supervisedmodel"},{"name":"t"}],"output":{"name":"result"}}],[0,"prelude","rustlearn","Basic data structures and traits used throughout `rustlearn`.",null,null]],"paths":[[3,"Array"],[3,"ArrayView"],[3,"ArrayIterator"],[3,"ArrayViewIterator"],[3,"ArrayViewNonzeroIterator"],[3,"SparseArrayView"],[3,"SparseRowArray"],[3,"SparseColumnArray"],[3,"SparseArrayViewIterator"],[3,"SparseArrayIterator"],[4,"MatrixOrder"],[8,"IndexableMatrix"],[8,"RowIterable"],[8,"ColumnIterable"],[8,"NonzeroIterable"],[8,"RowIndex"],[8,"ElementwiseArrayOps"],[8,"Dot"],[3,"CrossValidation"],[3,"ShuffleSplit"],[3,"Hyperparameters"],[3,"RandomForest"],[3,"Hyperparameters"],[3,"SGDClassifier"],[3,"OneVsRest"],[3,"OneVsRestWrapper"],[3,"DictVectorizer"],[3,"Hyperparameters"],[3,"DecisionTree"],[8,"SupervisedModel"]]};
initSearch(searchIndex);
